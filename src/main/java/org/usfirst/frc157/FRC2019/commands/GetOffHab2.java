// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc157.FRC2019.commands;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.command.Command;

import org.usfirst.frc157.FRC2019.OutriggerTask;
import org.usfirst.frc157.FRC2019.Robot;

/**
 *
 */
public class GetOffHab2 extends Command {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATION
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
    private int frontTarget = 0;
    private int backTarget = 0;
    private DriveTarget forward;
    private double startTime;

    private enum states {
        lower, drive, raise, done
    }
    private states state;
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public GetOffHab2()
    {
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.drive);
        requires(Robot.drive);
        requires(Robot.drive);

        forward = new DriveTarget(100, Robot.drive.getAngle(), 20, 2000, true);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    // Called just before this Command runs the first time
    @Override
    protected void initialize() {
        frontTarget = -20;
        backTarget = -20;
        startTime = Timer.getFPGATimestamp();
    }

    // Called repeatedly when this Command is scheduled to run
    @Override
    protected void execute()
    {
        double frontPos = Robot.frontOutriggers.frontOutrigger.getPosition();
        double backPos = Robot.backOutriggers.backOutrigger.getPosition();

        switch (state) {
            case lower:
                frontTarget = -54;
                backTarget = -41;
                if (Math.abs(frontPos-frontTarget)<3 && Math.abs(backPos-backTarget) < 3) {
                    state = states.drive;
                    startTime = Timer.getFPGATimestamp();
                }
                break;
            case drive:
                if (Timer.getFPGATimestamp()-startTime<1) {
                 //   drive.
                }
                break;
            case raise:
                frontTarget = 0;
                backTarget = 0;
                if (Math.abs(frontPos-frontTarget)<3 && Math.abs(backPos-backTarget) < 3) {
                    state = states.done;
                }
                break;
        }
        //Robot.outriggers.move((isA)?(-1):(1));
      //  System.out.println("\n------\n" + value + "\n" + target);
     //   double moveFront = Robot.frontOutriggers.yawFrontPID.pidCalculate(frontTarget, frontPos);
      //  double moveBack = Robot.backOutriggers.yawBackPID.pidCalculate(backTarget, backPos);
        OutriggerTask front = new OutriggerTask(frontTarget, 1,3, 1.0);// testing new code implementation to better controll outriggers individually
        OutriggerTask back = new OutriggerTask(backTarget, 1,3, 1.0); // testing new code to implement outriggers individuallmy
        Robot.frontOutriggers.tasks[Robot.frontOutriggers.climbTask]= front;
        Robot.backOutriggers.tasks[Robot.frontOutriggers.climbTask]= back;
    }

    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished()
    {
        return (state == states.done);
    }

    // Called once after isFinished returns true
    @Override
    protected void end() {
        Robot.drive.tankDrive(0, 0);
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
    }
}
