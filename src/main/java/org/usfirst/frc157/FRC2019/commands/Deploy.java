// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc157.FRC2019.commands;
import edu.wpi.first.wpilibj.command.Command;

import org.usfirst.frc157.FRC2019.OutriggerTask;
import org.usfirst.frc157.FRC2019.Robot;

/**
 *
 */
public class Deploy extends Command {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATION
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
    private int frontTarget = 0;
    private int backTarget = 0;
    private int liftTarget = 0;


    private enum states {
        raiseLift1, shiftOutrigger, raiseLift2, done
    }
    private states state;
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public Deploy()
    {
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.lift);
        requires(Robot.frontOutriggers);
        requires(Robot.backOutriggers);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    // Called just before this Command runs the first time
    @Override
    protected void initialize() {
        frontTarget = 0;
        liftTarget = 0;
    }

    // Called repeatedly when this Command is scheduled to run
    @Override
    protected void execute()
    {
        double frontPos = Robot.frontOutriggers.frontOutrigger.getPosition();
        double backPos = Robot.backOutriggers.backOutrigger.getPosition();
        double liftPos = Robot.lift.encoder.getDistance();


        switch (state) {
            case raiseLift1:
                liftTarget = 8;
                if (Math.abs(liftTarget-liftPos)<2) {
                    state = states.shiftOutrigger;
                }
                break;
            case shiftOutrigger:
                frontTarget = -8;
                if (Math.abs(frontPos-frontTarget)<3) {
                    state = states.raiseLift2;
                }
                break;
            case raiseLift2:
                liftTarget = 25;
                if (Math.abs(liftTarget-liftPos)<2) {
                    state = states.done;
                }
                break;
            }
        //Robot.outriggers.move((isA)?(-1):(1));
      //  System.out.println("\n------\n" + value + "\n" + target);
     //   double moveFront = Robot.frontOutriggers.yawFrontPID.pidCalculate(frontTarget, frontPos);
      //  double moveBack = Robot.backOutriggers.yawBackPID.pidCalculate(backTarget, backPos);
        OutriggerTask front = new OutriggerTask(frontTarget, 1,3, 1.0);// testing new code implementation to better controll outriggers individually
        Robot.frontOutriggers.tasks[Robot.frontOutriggers.liftTask]= front;
    }

    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished()
    {
        return (state == states.done);
    }

    // Called once after isFinished returns true
    @Override
    protected void end() {
        Robot.drive.tankDrive(0, 0);
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
    }
}
