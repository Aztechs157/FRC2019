// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc157.FRC2019.commands;

import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.command.Command;

import org.usfirst.frc157.FRC2019.OutriggerTask;
import org.usfirst.frc157.FRC2019.Robot;
import org.usfirst.frc157.FRC2019.subsystems.FrontOutriggers;

/**
 *
 */
public class Deploy extends Command {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATION
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
    private double frontTarget = 0;
    private int backTarget = 0;
    private int liftTarget = 0;
    private double startTime = 0;


    private enum states {
       raiseRobot, driveRobot, wait1, lowerRobot, wait, raiseOutriggers, done
    }
    private states state = states.raiseRobot;
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public Deploy()
    {
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        System.out.println("constructor");
        requires(Robot.lift);
        requires(Robot.drive);
        requires(Robot.intake);
        //requires(Robot.frontOutriggers);
        //requires(Robot.backOutriggers);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    // Called just before this Command runs the first time
    @Override
    protected void initialize() {
        System.out.println("initialize");

        frontTarget = 0;
        backTarget = 0;

        liftTarget = 0;
    }

    // Called repeatedly when this Command is scheduled to run
    @Override
    protected void execute()
    {
        double front1Pos = Robot.frontOutriggers.frontOutrigger1.getPosition();
        double front2Pos = Robot.frontOutriggers.frontOutrigger1.getPosition();

        double back1Pos = Robot.backOutriggers.backOutrigger1.getPosition();
        double back2Pos = Robot.backOutriggers.backOutrigger1.getPosition();


        double liftPos = Robot.lift.encoder.getDistance();
        OutriggerTask front =  new OutriggerTask(frontTarget, 1,1, 1.0);
        OutriggerTask back =  new OutriggerTask(backTarget, 1,1, 1.0);


        switch (state) {
            case raiseRobot:
                Robot.intake.move(0.65);
                frontTarget = -54;
                backTarget = -41;
                if (Math.abs(front1Pos-frontTarget)<5 && Math.abs(back1Pos-backTarget) < 5 
                    && Math.abs(front2Pos-frontTarget)<5 && Math.abs(back2Pos-backTarget) < 5) {
                    state = states.driveRobot;
                    startTime = Timer.getFPGATimestamp();
                }
                front = new OutriggerTask(frontTarget, 1,1, 0.5);
                back = new OutriggerTask(backTarget, 1,1, 0.5);
                break;
            case driveRobot:
                if (Timer.getFPGATimestamp()-startTime<1.45) {
                    Robot.drive.tankDrive(0.9, 0.9);
                }
                else {
                    state = states.wait1;
                    Robot.drive.tankDrive(0, 0);
                    startTime = Timer.getFPGATimestamp();
                }
                front = new OutriggerTask(frontTarget, 1,1, 1.0);
                back = new OutriggerTask(backTarget, 1,1, 1.0);
                break;
            case wait1:
                if (Timer.getFPGATimestamp()-startTime<0.4) {
                }
                else {
                    state = states.lowerRobot;
                    Robot.drive.tankDrive(0, 0);

                }
                break;
            case lowerRobot:
                frontTarget = -40;
                backTarget = -28;
                if (Math.abs(front1Pos-frontTarget)<4 && Math.abs(back1Pos-backTarget) < 4 
                    && Math.abs(front2Pos-frontTarget)<4 && Math.abs(back2Pos-backTarget) < 4) {
                    state = states.wait;

                    startTime = Timer.getFPGATimestamp();
                }
                front = new OutriggerTask(frontTarget, 1,1, 0.5);
                back = new OutriggerTask(backTarget, 1,1, 0.5);
                front.landing = true;
                back.landing = true;
                break;
            case wait:
                if (Timer.getFPGATimestamp()-startTime<0.9) {
                }
                else {
                    state = states.raiseOutriggers;
                    Robot.drive.tankDrive(0, 0);

                }
                break;
            case raiseOutriggers:
                frontTarget = -2;
                backTarget = -2;
                if (Math.abs(front1Pos-frontTarget)<3 && Math.abs(back1Pos-backTarget) < 3 
                    && Math.abs(front2Pos-frontTarget)<3 && Math.abs(back2Pos-backTarget) < 3) {
                    state = states.done;
                }
                front = new OutriggerTask(frontTarget, 1,1, 0.7);
                back = new OutriggerTask(backTarget, 1,1, 0.7);
                front.landing = false;
                back.landing = false;
                break;
        }
        //Robot.outriggers.move((isA)?(-1):(1));
      //  System.out.println("\n------\n" + value + "\n" + target);
     //   double moveFront = Robot.frontOutriggers.yawFrontPID.pidCalculate(frontTarget, frontPos);
      //  double moveBack = Robot.backOutriggers.yawBackPID.pidCalculate(backTarget, back1Pos);
        Robot.frontOutriggers.tasks[Robot.frontOutriggers.liftTask]= front;
        Robot.backOutriggers.tasks[Robot.backOutriggers.liftTask]= back;

        Robot.lift.moveLift(1, liftTarget);
    }

    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished()
    {
        System.out.println(state);
        return (state == states.done);
      //  return false;
    }

    // Called once after isFinished returns true
    @Override
    protected void end() {
        Robot.drive.tankDrive(0, 0);
        OutriggerTask nullpos =  new OutriggerTask(0, 9,9, 0);
        Robot.frontOutriggers.tasks[Robot.frontOutriggers.liftTask]= nullpos;
        Robot.backOutriggers.tasks[Robot.backOutriggers.liftTask]= nullpos;
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
    }
}
